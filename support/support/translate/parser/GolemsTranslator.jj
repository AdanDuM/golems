/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\GolemsTranslator.jj */
/*@egen*//**
* JJTree file
*/

options {                   
  STATIC = true;
  JAVA_UNICODE_ESCAPE=true;
  UNICODE_INPUT=true;
  JDK_VERSION = "1.5";                             //so it doesnt overwrite existing nodes accidently
}
 
PARSER_BEGIN(Translator) 
package support.translate.parser;

public class Translator/*@bgen(jjtree)*/implements TranslatorTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTTranslatorState jjtree = new JJTTranslatorState();

/*@egen*/

}
PARSER_END(Translator)

SKIP :
{
  " " 
| "\t"
| "\n"
| "\r"
| "\r\n"
|<"#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}/*
SPECIAL_TOKEN : {

    < SINGLE_LINE_COMMENT: "#"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > 
    } 
*/

TOKEN :
{
    <CLOSE_CLASS: "}">
}


TOKEN : 
{
  < KEY: (["A"-"Z"]) (["A"-"Z","0"-"9","_","-","."])* "~"> //(~[":","{","}","#","\n","\r"," "])+  >
}



TOKEN : 
{
  < CLASS: (["A"-"Z"]) (["A"-"Z","0"-"9","_","-"])* "{"> //(~[":","{","}","#","\n","\r"," "])+  >
}

TOKEN :   
{//must have atleast 1 non space character
  < ENTRY: (~["~","{","}","#","\n","\r", " "]) (~["~","{","}","#"])* (["\r" , "\n"] | "\r\n")  > //require the statement to end on a new line.
 //< ENTRY: ([":"]) (~[":"]) ([":"](?!":"))* (["\r" , "\n"] | "\r\n")  > //require the statement to end on a new line.

}
/*TOKEN : 
{
  < CLASS: (~["\n","\r", ":"])+ "{" >
}
TOKEN : 
{
  < RESULT: (~[":" "{"])+ >//note: a result can contain new lines
}
*/
SimpleNode Start():{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
   try {
/*@egen*/
    


   (entry())+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  { return jjtn000; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


void entry()     :
{Token e;}
{
    (e= <KEY> simpleEntry(e))
     
     | (e= <CLASS> readClass(e))
  
}

void simpleEntry(Token e)            :
{/*@bgen(jjtree) Definition */
ASTDefinition jjtn000 = new ASTDefinition(JJTDEFINITION);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t = null;}
{/*@bgen(jjtree) Definition */
   try {
/*@egen*/
  
  
   (t=<ENTRY>)?/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/

   {jjtn000.setKey(e); jjtn000.setEntry(t);}/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void readClass(Token t)                :
{/*@bgen(jjtree) DefinitionClass */
  ASTDefinitionClass jjtn000 = new ASTDefinitionClass(JJTDEFINITIONCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefinitionClass */
    try {
/*@egen*/
   
    {jjtn000.setName(t);jjtn000.setLine(t.endLine);}
    (entry())*
    
    <CLOSE_CLASS>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}




