Index: .classpath
===================================================================
--- .classpath	(revision 4046)
+++ .classpath	(working copy)
@@ -1,15 +1,19 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="junit"/>
 	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="lib/lwjgl/jinput.jar"/>
+	<classpathentry kind="lib" path="lib/lwjgl/lwjgl_util_applet.jar"/>
+	<classpathentry kind="lib" path="lib/lwjgl/lwjgl_util.jar"/>
+	<classpathentry kind="lib" path="lib/lwjgl/lwjgl.jar">
+		<attributes>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="jme2/lib/lwjgl/native/win32"/>
+		</attributes>
+	</classpathentry>
 	<classpathentry kind="lib" path="lib/jogl/gluegen-rt.jar"/>
 	<classpathentry kind="lib" path="lib/jogl/jogl.jar"/>
 	<classpathentry kind="lib" path="lib/jorbis/jorbis-0.0.17.jar"/>
 	<classpathentry kind="lib" path="lib/junit/junit-4.1.jar"/>
-	<classpathentry kind="lib" path="lib/lwjgl/jinput.jar"/>
-	<classpathentry kind="lib" path="lib/lwjgl/lwjgl_util_applet.jar"/>
-	<classpathentry kind="lib" path="lib/lwjgl/lwjgl_util.jar"/>
-	<classpathentry kind="lib" path="lib/lwjgl/lwjgl.jar"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="lib/swt/windows/swt.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: .project
===================================================================
--- .project	(revision 4046)
+++ .project	(working copy)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>jme</name>
+	<name>jme2</name>
 	<comment></comment>
 	<projects>
 	</projects>
Index: src/com/jme/scene/ConnectionPoint.java
===================================================================
--- src/com/jme/scene/ConnectionPoint.java	(revision 4046)
+++ src/com/jme/scene/ConnectionPoint.java	(working copy)
@@ -34,10 +34,11 @@
         if(target == null) {
             return;
         }
-        if (((lockedMode & Spatial.LOCKED_TRANSFORMS) == 0)) {
+        if ((((lockedMode & LOCKED_TRANSFORMS) == 0)) || ((dirtyLocks & LOCKED_TRANSFORMS) != 0)) {
             worldScale.set(parent.getWorldScale()).multLocal(target.getWorldScale());
             parent.getWorldRotation().mult(target.getWorldRotation(), worldRotation);
             worldTranslation = parent.localToWorld( target.getWorldTranslation(), worldTranslation );
+            dirtyLocks &= (~LOCKED_TRANSFORMS);
         }
     }
     
Index: src/com/jme/scene/Geometry.java
===================================================================
--- src/com/jme/scene/Geometry.java	(revision 4046)
+++ src/com/jme/scene/Geometry.java	(working copy)
@@ -532,8 +532,51 @@
      */
     @Override
     public void draw(Renderer r) {
+       	if ((this.lockedMode & LOCKED_MESH_DATA) != 0)
+    	{
+    		if ((this.dirtyLocks & LOCKED_MESH_DATA) != 0)
+    		{
+    			//refresh the display list
+    			this.clearDisplayList(r);
+    			this.buildDisplayList(r);
+    			  dirtyLocks &= (~LOCKED_MESH_DATA);
+    		}else if (!this.hasDisplayList())
+    		{
+    			this.buildDisplayList(r);
+    		}
+    	}else
+    	{
+    		clearDisplayList(r);
+    	}
     }
 
+    protected void buildDisplayList(Renderer r)
+    {
+        if (hasDisplayList()) {
+			logger.warning("This GeomBatch already has locked meshes."
+                    + "(Use unlockMeshes to clear)");
+			return;
+		}
+    	
+    	updateRenderState();
+    	
+        setDisplayListID(r.createDisplayList(this));
+    }
+    
+    protected boolean hasDisplayList()
+    {
+    	return getDisplayListID() != -1;
+    }
+    
+    protected void clearDisplayList(Renderer r)
+    {
+        if (getDisplayListID() != -1) {
+            r.releaseDisplayList(getDisplayListID());
+            setDisplayListID(-1);
+            updateRenderState();
+        }
+    }
+    
     /**
      * <code>updateWorldBound</code> updates the bounding volume that contains
      * this geometry. The location of the geometry is based on the location of
@@ -777,27 +820,13 @@
     }
 
     @Override
-    public void lockMeshes(Renderer r) {
-        if (getDisplayListID() != -1) {
-            logger.warning("This Geometry already has locked meshes."
-                    + "(Use unlockMeshes to clear)");
-            return;
-        }
-
-        updateRenderState();
+    public void lockMeshes() {
         lockedMode |= LOCKED_MESH_DATA;
-
-        setDisplayListID(r.createDisplayList(this));
     }
 
     @Override
-    public void unlockMeshes(Renderer r) {
+    public void unlockMeshes() {
         lockedMode &= ~LOCKED_MESH_DATA;
-
-        if (getDisplayListID() != -1) {
-            r.releaseDisplayList(getDisplayListID());
-            setDisplayListID(-1);
-        }
     }
 
     /**
Index: src/com/jme/scene/Node.java
===================================================================
--- src/com/jme/scene/Node.java	(revision 4046)
+++ src/com/jme/scene/Node.java	(working copy)
@@ -399,7 +399,8 @@
 
     @Override
     public void updateWorldVectors(boolean recurse) {
-        if (((lockedMode & Spatial.LOCKED_TRANSFORMS) == 0)) {
+    	if ((((lockedMode & LOCKED_TRANSFORMS) == 0)) || ((dirtyLocks & LOCKED_TRANSFORMS) != 0)) {
+   		 
             updateWorldScale();
             updateWorldRotation();
             updateWorldTranslation();
@@ -409,6 +410,7 @@
                     children.get(i).updateWorldVectors(true);
                 }
             }
+            dirtyLocks &= (~LOCKED_TRANSFORMS);
         }
     }
     
@@ -446,17 +448,38 @@
     }
 
     @Override
-    public void lockMeshes(Renderer r) {
-        super.lockMeshes(r);
+    public void lockMeshes() {
+        super.lockMeshes();
         for (int i = 0, max = getQuantity(); i < max; i++) {
             Spatial child =  children.get(i);
             if (child != null) {
-                child.lockMeshes(r);
+                child.lockMeshes();
             }
         }
     }
     
     @Override
+    public void lockBranch() {
+        super.lockBranch();
+        for (int i = 0, max = getQuantity(); i < max; i++) {
+            Spatial child =  children.get(i);
+            if (child != null) {
+                child.lockBranch();
+            }
+        }
+    }
+    
+    @Override
+    public void unlockBranch() {
+        super.unlockBranch();
+        for (int i = 0, max = getQuantity(); i < max; i++) {
+            Spatial child =  children.get(i);
+            if (child != null) {
+                child.unlockBranch();
+            }
+        }
+    }
+    @Override
     public void unlockBounds() {
         super.unlockBounds();
         for (int i = 0, max = getQuantity(); i < max; i++) {
@@ -490,12 +513,12 @@
     }
 
     @Override
-    public void unlockMeshes(Renderer r) {
-        super.unlockMeshes(r);
+    public void unlockMeshes() {
+        super.unlockMeshes();
         for (int i = 0, max = getQuantity(); i < max; i++) {
             Spatial child =  children.get(i);
             if (child != null) {
-                child.unlockMeshes(r);
+                child.unlockMeshes();
             }
         }
     }
@@ -560,8 +583,10 @@
      */
     @Override
     public void updateWorldBound() {
-        if ((lockedMode & Spatial.LOCKED_BOUNDS) != 0) return;
+        if (((lockedMode & LOCKED_BOUNDS) != 0) && ((dirtyLocks & LOCKED_BOUNDS) == 0)) return;
+        
         if (children == null) {
+        	dirtyLocks &= (~LOCKED_BOUNDS);  
             return;
         }
         BoundingVolume worldBound = null;
@@ -581,6 +606,7 @@
             }
         }
         this.worldBound = worldBound;
+        dirtyLocks &= (~LOCKED_BOUNDS);
     }
 
     @Override
Index: src/com/jme/scene/SharedMesh.java
===================================================================
--- src/com/jme/scene/SharedMesh.java	(revision 4046)
+++ src/com/jme/scene/SharedMesh.java	(working copy)
@@ -618,8 +618,8 @@
     }
 
     @Override
-    public void lockMeshes(Renderer r) {
-        target.lockMeshes(r);
+    public void lockMeshes() {
+        target.lockMeshes();
     }
 
     @Override
Index: src/com/jme/scene/Spatial.java
===================================================================
--- src/com/jme/scene/Spatial.java	(revision 4046)
+++ src/com/jme/scene/Spatial.java	(working copy)
@@ -188,8 +188,42 @@
     public static final int LOCKED_TRANSFORMS = 4;
     public static final int LOCKED_SHADOWS = 8;
     public static final int LOCKED_BRANCH = 16;
+    public static final int LOCKED_ALL = LOCKED_BRANCH | LOCKED_SHADOWS | LOCKED_TRANSFORMS | LOCKED_MESH_DATA | LOCKED_BOUNDS;
 
+    
     /**
+     * This entire branch of the scene graph has its locks dirtied so that it can be
+     * updated/rendered (it will ignore locks).
+     * @param locksToDirty A bit flag containing each lock to dirty
+     */
+    public void refreshBranch(int locksToDirty)
+    {
+    	refreshBranchToRoot(locksToDirty);
+    	refreshBranchToLeaves(locksToDirty);
+    }
+    
+    public void refreshBranch()
+    {
+    	refreshBranch(LOCKED_ALL);
+    }
+    
+    /**
+     * Refresh upward in this scene graph to the root node
+     */
+    protected void refreshBranchToRoot(int locksToDirty)
+    {
+    	this.dirtyLocks |= locksToDirty;
+    	
+    }
+    
+    /**
+     * Refresh downward in the scene graph to each leaf of element
+     */
+    protected void refreshBranchToLeaves(int locksToDirty)
+    {
+    	this.dirtyLocks |= locksToDirty;
+    }
+    /**
      * A flag indicating how normals should be treated by the renderer.
      */
     protected NormalsMode normalsMode = NormalsMode.Inherit;
@@ -216,8 +250,15 @@
      * locked against certain changes.
      */
     protected int lockedMode = LOCKED_NONE;
-
+    
     /**
+     * The locks belonging to this scene element that should be temporarily ignored,
+     * because they need to be updated (just once). The locks indicated in this field will be
+     * removed (from dirtyLocks) once they have been updated.
+     */
+    protected int dirtyLocks = LOCKED_NONE;
+    
+    /**
      * Flag signaling how lights are combined for this node. By default set to
      * INHERIT.
      */
@@ -511,15 +552,18 @@
      *            true if this node started the update process.
      */
     public void updateGeometricState(float time, boolean initiator) {
-        if ((lockedMode & Spatial.LOCKED_BRANCH) != 0)
-            return;
+    	if (((lockedMode & LOCKED_BRANCH) != 0) && ((dirtyLocks & LOCKED_BRANCH) == 0) ) 
+    		return;
+ 
         updateWorldData(time);
-        if ((lockedMode & Spatial.LOCKED_BOUNDS) == 0) {
+        if (((lockedMode & LOCKED_BOUNDS) == 0)  || ((dirtyLocks & LOCKED_BOUNDS) != 0)) {
             updateWorldBound();
             if (initiator) {
                 propagateBoundToRoot();
             }
+            dirtyLocks &= (~LOCKED_BOUNDS);
         }
+        dirtyLocks &= (~LOCKED_BRANCH);
     }
 
     /**
@@ -567,10 +611,12 @@
      *            updating geometric state.
      */
     public void updateWorldVectors(boolean recurse) {
-        if (((lockedMode & Spatial.LOCKED_TRANSFORMS) == 0)) {
+    	if ((((lockedMode & LOCKED_TRANSFORMS) == 0)) || ((dirtyLocks & LOCKED_TRANSFORMS) != 0)) {
+    		    
             updateWorldScale();
             updateWorldRotation();
             updateWorldTranslation();
+            dirtyLocks &= (~LOCKED_TRANSFORMS);
         }
     }
 
@@ -1240,52 +1286,18 @@
      * provide a guarentee that data changes will not be allowed or will/won't
      * show up in the scene. It is merely a hint to the engine.
      * 
-     * @param r
-     *            A renderer to lock against.
      * @see #unlockMeshes(Renderer)
      */
-    public void lockMeshes(Renderer r) {
-        updateRenderState();
+    public void lockMeshes() {
         lockedMode |= LOCKED_MESH_DATA;
     }
 
-    /**
-     * Flags this spatial and those below it that any meshes in the specified
-     * scenegraph location or lower will not have changes in vertex, texcoord,
-     * normal or color data. This allows optimizations by the engine such as
-     * creating display lists from the data. Calling this method does not
-     * provide a guarentee that data changes will not be allowed or will/won't
-     * show up in the scene. It is merely a hint to the engine. Calls
-     * lockMeshes(Renderer) with the current display system's renderer.
-     * 
-     * @see #lockMeshes(Renderer)
-     */
-    public void lockMeshes() {
-        lockMeshes(DisplaySystem.getDisplaySystem().getRenderer());
-    }
 
     /**
-     * Convienence function for locking all aspects of a Spatial.
-     * 
+     * Convienence function for locking all aspects of a Spatial. 
+  
      * @see #lockBounds()
      * @see #lockTransforms()
-     * @see #lockMeshes(Renderer)
-     * @see #lockShadows()
-     */
-    public void lock(Renderer r) {
-        lockBounds();
-        lockTransforms();
-        lockMeshes(r);
-        lockShadows();
-    }
-
-    /**
-     * Convienence function for locking all aspects of a Spatial. For lockMeshes
-     * it calls:
-     * <code>lockMeshes(DisplaySystem.getDisplaySystem().getRenderer());</code>
-     * 
-     * @see #lockBounds()
-     * @see #lockTransforms()
      * @see #lockMeshes()
      * @see #lockShadows()
      */
@@ -1336,49 +1348,19 @@
         lockedMode &= ~LOCKED_TRANSFORMS;
     }
 
-    /**
-     * Flags this spatial and those below it to allow for mesh updating (the
-     * default). Generally this means that any display lists setup will be
-     * erased and released. Calls unlockMeshes(Renderer) with the current
-     * display system's renderer.
-     * 
-     * @see #unlockMeshes(Renderer)
-     */
-    public void unlockMeshes() {
-        unlockMeshes(DisplaySystem.getDisplaySystem().getRenderer());
-    }
 
     /**
      * Flags this spatial and those below it to allow for mesh updating (the
      * default). Generally this means that any display lists setup will be
      * erased and released.
      * 
-     * @param r
-     *            The renderer used to lock against.
      * @see #lockMeshes(Renderer)
      */
-    public void unlockMeshes(Renderer r) {
+    public void unlockMeshes() {
         lockedMode &= ~LOCKED_MESH_DATA;
     }
 
     /**
-     * Convienence function for unlocking all aspects of a Spatial.
-     * 
-     * @see #unlockBounds()
-     * @see #unlockTransforms()
-     * @see #unlockMeshes(Renderer)
-     * @see #unlockShadows()
-     * @see #unlockBranch()
-     */
-    public void unlock(Renderer r) {
-        unlockBounds();
-        unlockTransforms();
-        unlockMeshes(r);
-        unlockShadows();
-        unlockBranch();
-    }
-
-    /**
      * Convienence function for unlocking all aspects of a Spatial. For
      * unlockMeshes it calls:
      * <code>unlockMeshes(DisplaySystem.getDisplaySystem().getRenderer());</code>
@@ -1414,35 +1396,36 @@
      *            Spatial.
      */
     public void setLocks(int locks) {
-        if ((lockedMode & Spatial.LOCKED_BOUNDS) != 0)
-            lockBounds();
-        if ((lockedMode & Spatial.LOCKED_MESH_DATA) != 0)
-            lockMeshes();
-        if ((lockedMode & Spatial.LOCKED_SHADOWS) != 0)
-            lockShadows();
-        if ((lockedMode & Spatial.LOCKED_TRANSFORMS) != 0)
-            lockTransforms();
-    }
 
-    /**
-     * @param locks
-     *            a bitwise combination of the locks to establish on this
-     *            Spatial.
-     * @param r
-     *            the renderer to create display lists with if LOCKED_MESH_DATA
-     *            is set.
-     */
-    public void setLocks(int locks, Renderer r) {
-        if ((lockedMode & Spatial.LOCKED_BOUNDS) != 0)
-            lockBounds();
-        if ((lockedMode & Spatial.LOCKED_MESH_DATA) != 0)
-            lockMeshes(r);
-        if ((lockedMode & Spatial.LOCKED_SHADOWS) != 0)
-            lockShadows();
-        if ((lockedMode & Spatial.LOCKED_TRANSFORMS) != 0)
-            lockTransforms();
+        	if ((locks & LOCKED_BOUNDS) != 0)
+        		lockBounds();
+        	else
+        		unlockBounds();
+       
+        	if ((locks & LOCKED_TRANSFORMS) != 0)
+        		lockTransforms();
+        	else
+        		unlockTransforms();
+       
+        	if ((locks & LOCKED_MESH_DATA) != 0)
+        		lockMeshes();
+        	else
+        		unlockMeshes();
+       
+        	if ((locks & LOCKED_SHADOWS) != 0)
+        		lockShadows();
+        	else
+        		unlockShadows();
+      
+        	if ((locks & LOCKED_BRANCH) != 0)
+        		lockBranch();
+        	else
+        		unlockBranch();
+        
     }
 
+
+
     /**
      * <code>updateWorldBound</code> updates the bounding volume of the world.
      * Abstract, geometry transforms the bound while node merges the children's
