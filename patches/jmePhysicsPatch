Index: impl/ode/src/org/odejava/collision/Collision.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/collision/Collision.java,v
retrieving revision 1.4
diff -u -r1.4 Collision.java
--- impl/ode/src/org/odejava/collision/Collision.java   22 Sep 2007 14:29:16 -0000  1.4
+++ impl/ode/src/org/odejava/collision/Collision.java   11 Jul 2009 22:23:56 -0000
@@ -27,6 +27,9 @@
  */
 package org.odejava.collision;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.odejava.ode.Ode;
 import org.odejava.ode.SWIGTYPE_p_dJointGroupID;
 
@@ -46,6 +49,8 @@
 
 public abstract class Collision {
 
+   private static final List<SWIGTYPE_p_dJointGroupID> contacts = new ArrayList<SWIGTYPE_p_dJointGroupID>();
+   
     protected SWIGTYPE_p_dJointGroupID contactGroupId;
 
     /**
@@ -60,8 +65,10 @@
     // contacts are to be stored.
     public Collision() {
         deleted = false;
+      
         // Create contact joint group for collision routines
         contactGroupId = Ode.dJointGroupCreate( 0 );
+        contacts.add(contactGroupId);
 //        Ode.setContactGroupID( contactGroupId );
     }
 
@@ -69,9 +76,11 @@
         if ( deleted ) {
             return;
         }
-
+ 
         // Delete contact joint group
         Ode.dJointGroupDestroy( contactGroupId );
+        contacts.remove(contactGroupId);
+        
         deleted = true;
     }
 
@@ -164,4 +173,14 @@
     public void setSurfaceSoftErp( float softErp ) {
         Ode.setSurfaceSoftErp( softErp );
     }
+    
+    /**
+     * Delete all collision groups that have not already been deleted.
+     */
+    public static void deleteAllContacts()
+    {
+       for (SWIGTYPE_p_dJointGroupID jointID:contacts)
+           Ode.dJointGroupDestroy(jointID);
+       contacts.clear();
+    }
 }
Index: impl/ode/src/org/odejava/collision/JavaCollision.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/collision/JavaCollision.java,v
retrieving revision 1.10
diff -u -r1.10 JavaCollision.java
--- impl/ode/src/org/odejava/collision/JavaCollision.java   16 Mar 2008 19:11:42 -0000  1.10
+++ impl/ode/src/org/odejava/collision/JavaCollision.java   11 Jul 2009 22:23:56 -0000
@@ -86,7 +86,7 @@
         if ( world == null ) {
             throw new NullPointerException( VALID_WORLD_REQ_ERR );
         }
-
+        
         worldId = world.getId();
         contactBuffer1 = Odejava.getContactIntBuf();
         contactBuffer1.order( ByteOrder.nativeOrder() );
@@ -126,6 +126,7 @@
 
         // Collide objects, generates all contacts
         contactCount = Ode.spaceCollide( space.getId() );
+    
     }
 
     //FIX ME: this is quite a hack - it would be better to avoid using native pointers at all
@@ -190,7 +191,13 @@
     }
 
 
-    /**
+    @Override
+   public void emptyContactGroup() {
+       super.emptyContactGroup();
+       
+   }
+
+   /**
      * Apply contact data to simulation. Adds all contact joints to contact
      * jointgroup. Call this after spaceCollide call if you are not creating
      * contact joints manually at the Java side. Collision can be done with
@@ -210,6 +217,7 @@
         // Add all contacts to contact jointgroup in a single call
         if ( contactCount > 0 ) {
             Odejava.createContactJoints( worldId, contactGroupId );
+          
         }
     }
 
Index: impl/ode/src/org/odejava/collision/Contact.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/collision/Contact.java,v
retrieving revision 1.5
diff -u -r1.5 Contact.java
--- impl/ode/src/org/odejava/collision/Contact.java 5 Jul 2006 09:41:03 -0000   1.5
+++ impl/ode/src/org/odejava/collision/Contact.java 11 Jul 2009 22:23:56 -0000
@@ -30,8 +30,11 @@
 import java.nio.FloatBuffer;
 import java.nio.LongBuffer;
 
-import com.jme.math.Vector3f;
 import org.odejava.Geom;
+import org.odejava.JointFeedback;
+import org.odejava.ode.SWIGTYPE_p_void;
+
+import com.jme.math.Vector3f;
 
 /**
  * This class can be used for accessing collision data buffers. Usable only
@@ -52,13 +55,17 @@
             "Index is past the end of the maximum number of held contacts";
 
     // intBuf chunk structure
-    public static final int INTBUF_CHUNK_SIZE = 5;
+    public static final int INTBUF_CHUNK_SIZE = 6;
     public static final int GEOM_ID1 = 0;
     public static final int GEOM_ID2 = 1;
     public static final int BODY_ID1 = 2;
     public static final int BODY_ID2 = 3;
     public static final int MODE = 4;
-
+    public static final int FEEDBACK = 5;
+    //to add contact feedback, have to add another pointer slot into the chunk structure in the Odejava c code
+    //then we can add in the pointer to the dfeedback structure here, and the odejava c-code can catch check if it is null or not, and add it.
+    
+    
     // floatBuf chunk structure
     public static final int FLOATBUF_CHUNK_SIZE = 20;
     public static final int POSITION = 0;
@@ -107,7 +114,7 @@
         this.longBuf = longBuf;
         this.floatBuf = floatBuf;
         index = 0;
-
+       
         maxContacts = longBuf.capacity() / INTBUF_CHUNK_SIZE;
     }
 
@@ -630,6 +637,11 @@
         floatBuf.put( idx * FLOATBUF_CHUNK_SIZE + BOUNCE_VEL, bounceVel );
     }
 
+    public void enableFeedback(JointFeedback feedback)
+    {
+         longBuf.put( index * INTBUF_CHUNK_SIZE + FEEDBACK,SWIGTYPE_p_void.getCPtr( feedback.getFeedback().getVoidPointer()));
+    }
+    
     /**
      * Contact normal ``softness'' parameter. This is only set if the corresponding flag is set in mode.
      *
Index: ant/module_physics.ode.xml
===================================================================
RCS file: /cvs/jmephysics/ant/module_physics.ode.xml,v
retrieving revision 1.5
diff -u -r1.5 module_physics.ode.xml
--- ant/module_physics.ode.xml  27 Nov 2007 09:29:39 -0000  1.5
+++ ant/module_physics.ode.xml  11 Jul 2009 22:23:54 -0000
@@ -75,7 +75,7 @@
             depends="compile.module.physics.ode.production,compile.module.physics.ode.tests"
             description="Compile module physics.ode"/>
 
-    <target name="compile.module.physics.ode.production" depends="compile.module.physics"
+    <target name="compile.module.physics.ode.production" 
             description="Compile module physics.ode; production classes">
         <mkdir dir="${physics.ode.output.dir}"/>
         <javac destdir="${physics.ode.output.dir}" debug="${compiler.debug}" nowarn="${compiler.generate.no.warnings}"
Index: ant/module_physics.xml
===================================================================
RCS file: /cvs/jmephysics/ant/module_physics.xml,v
retrieving revision 1.6
diff -u -r1.6 module_physics.xml
--- ant/module_physics.xml  27 Nov 2007 09:29:39 -0000  1.6
+++ ant/module_physics.xml  11 Jul 2009 22:23:54 -0000
@@ -57,7 +57,7 @@
 
 
     <patternset id="excluded.from.module.physics">
-        <patternset refid="ignored.files"/>
+      <patternset refid="ignored.files"/> 
     </patternset>
 
     <patternset id="excluded.from.compilation.physics">
@@ -90,6 +90,7 @@
             <bootclasspath refid="physics.module.bootclasspath"/>
             <classpath refid="physics.module.classpath"/>
             <src refid="physics.module.sourcepath"/>
+            <src path= "C:/Users/Sam/workspace2/jmephysics/src"/>
         </javac>
 
         <copy todir="${physics.output.dir}">
@@ -161,4 +162,89 @@
         <delete dir="${physics.output.dir}"/>
         <delete dir="${physics.testoutput.dir}"/>
     </target>
+   
+    <property name="module.physics.ode.basedir" location="impl/ode"/>
+
+
+       <property name="compiler.args.physics.ode" value="${compiler.args}"/>
+
+       <property name="physics.ode.output.dir" value="${module.physics.ode.basedir}/classes"/>
+       <property name="physics.ode.testoutput.dir" value="${module.physics.ode.basedir}/classes"/>
+
+       <path id="physics.ode.module.bootclasspath">
+           <!-- Paths to be included in compilation bootclasspath -->
+       </path>
+
+       <path id="physics.ode.module.classpath">
+           <pathelement location="${module.physics.ode.basedir}/lib/odejava-jni.jar"/>
+           <pathelement location="${physics.output.dir}"/>
+           <pathelement location="${jme.output.dir}"/>
+           <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/jogg-0.0.5.jar"/>
+           <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/lwjgl.jar"/>
+           <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/jorbis-0.0.12.jar"/>
+           <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/lwjgl_fmod3.jar"/>
+           <path refid="library.junit.classpath"/>
+       </path>
+
+
+       <patternset id="excluded.from.module.physics.ode">
+           <patternset refid="ignored.files"/>
+       </patternset>
+
+       <patternset id="excluded.from.compilation.physics.ode">
+           <patternset refid="excluded.from.module.physics.ode"/>
+       </patternset>
+
+       <path id="physics.ode.module.sourcepath">
+           <dirset dir="${module.physics.ode.basedir}">
+               <include name="src"/>
+           </dirset>
+       </path>
+
+
+       <target name="compile.module.physics.ode"
+               depends="compile.module.physics.ode.production,compile.module.physics.ode.tests"
+               description="Compile module physics.ode"/>
+
+       <target name="compile.module.physics.ode.production" 
+               description="Compile module physics.ode; production classes">
+           <mkdir dir="${physics.ode.output.dir}"/>
+           <javac destdir="${physics.ode.output.dir}" debug="${compiler.debug}" nowarn="${compiler.generate.no.warnings}"
+                  memoryMaximumSize="${compiler.max.memory}" fork="true">
+               <compilerarg line="${compiler.args.physics.ode}"/>
+               <bootclasspath refid="physics.ode.module.bootclasspath"/>
+               <classpath refid="physics.ode.module.classpath"/>
+               <src refid="physics.ode.module.sourcepath"/>
+           </javac>
+
+           <copy todir="${physics.ode.output.dir}">
+               <fileset dir="${module.physics.ode.basedir}/src">
+                   <patternset refid="compiler.resources"/>
+                   <type type="file"/>
+               </fileset>
+           </copy>
+       </target>
+
+       <target name="release.module.physics.ode" depends="compile.module.physics.ode.production, release.module.physics">
+           <jar jarfile="${physics.release.dir}/jme-physics.jar" basedir="${physics.ode.output.dir}" update="yes"
+                compress="true"
+                includes="**"/>
+           <mkdir dir="${physics.release.dir}/lib"/>
+           <copy todir="${physics.release.dir}/lib">
+               <fileset dir="${module.physics.ode.basedir}/lib">
+                   <include name="*.dll"/>
+                   <include name="*.so"/>
+                   <include name="*.*lib"/>
+                   <include name="*.jar"/>
+               </fileset>
+           </copy>
+       </target>
+
+       <target name="compile.module.physics.ode.tests" depends="compile.module.physics.ode.production"
+               description="compile module physics.ode; test classes" unless="skip.tests"/>
+
+       <target name="clean.module.physics.ode" description="cleanup module">
+           <delete dir="${physics.ode.output.dir}"/>
+           <delete dir="${physics.ode.testoutput.dir}"/>
+       </target>
 </project>
\ No newline at end of file
Index: ant/build.xml
===================================================================
RCS file: /cvs/jmephysics/ant/build.xml,v
retrieving revision 1.4
diff -u -r1.4 build.xml
--- ant/build.xml   22 Sep 2007 14:28:39 -0000  1.4
+++ ant/build.xml   11 Jul 2009 22:23:54 -0000
@@ -36,12 +36,12 @@
 
     <property file="ant/build.properties"/>
 
-    <property name="module.jme.basedir" location="../jME"/>
+    <property name="module.jme.basedir" location="../jme"/>
     <!-- Uncomment the following property if no tests compilation is needed -->
     <!--
-   <property name="skip.tests" value="true"/>
+   
     -->
-
+   <property name="skip.tests" value="true"/>
     <!-- Compiler options -->
 
     <property name="compiler.debug" value="on"/>
@@ -84,7 +84,7 @@
 
     <import file="${basedir}/ant/module_physics.xml"/>
 
-    <import file="${basedir}/ant/module_physics.ode.xml"/>
+ 
 
     <target name="init" description="Build initialization">
         <!-- Perform any build initialization in this target -->
@@ -107,5 +107,219 @@
             </zipfileset>
         </zip>
     </target>
+    <property name="module.physics.basedir" location="."/>
+
+
+       <property name="compiler.args.physics" value="${compiler.args}"/>
 
+       <property name="physics.output.dir" value="${module.physics.basedir}/classes"/>
+       <property name="physics.testoutput.dir" value="${module.physics.basedir}/classes"/>
+       <property name="physics.release.dir" value="${module.physics.basedir}/release"/>
+       <property name="physics.javadoc.dir" value="${physics.release.dir}/api"/>
+
+       <path id="physics.module.bootclasspath">
+           <!-- Paths to be included in compilation bootclasspath -->
+       </path>
+
+       <path id="physics.module.classpath">
+           <path refid="library.junit.classpath"/>
+           <pathelement location="${jme.output.dir}"/>
+           <pathelement location="${module.physics.basedir}/../jME/lib/jogg-0.0.5.jar"/>
+           <pathelement location="${module.physics.basedir}/../jME/lib/lwjgl.jar"/>
+           <pathelement location="${module.physics.basedir}/../jME/lib/jorbis-0.0.12.jar"/>
+           <pathelement location="${module.physics.basedir}/../jME/lib/lwjgl_fmod3.jar"/>
+       </path>
+
+
+       <patternset id="excluded.from.module.physics">
+         <patternset refid="ignored.files"/> 
+       </patternset>
+
+       <patternset id="excluded.from.compilation.physics">
+           <patternset refid="excluded.from.module.physics"/>
+       </patternset>
+
+       <path id="physics.module.sourcepath">
+           <dirset dir="${module.physics.basedir}">
+               <include name="src"/>
+           </dirset>
+       </path>
+
+       <path id="physics.module.test.sourcepath">
+           <dirset dir="${module.physics.basedir}">
+               <include name="test"/>
+               <include name="test-interactive"/>
+           </dirset>
+       </path>
+
+
+       <target name="compile.module.physics" depends="compile.module.physics.production,compile.module.physics.tests"
+               description="Compile module physics"/>
+
+       <target name="compile.module.physics.production"
+               description="Compile module physics; production classes"> <!--depends="compile.module.jme"-->
+           <mkdir dir="${physics.output.dir}"/>
+           <javac destdir="${physics.output.dir}" debug="${compiler.debug}" nowarn="${compiler.generate.no.warnings}"
+                  memoryMaximumSize="${compiler.max.memory}" fork="true">
+               <compilerarg line="${compiler.args.physics}"/>
+               <bootclasspath refid="physics.module.bootclasspath"/>
+               <classpath refid="physics.module.classpath"/>
+               <src refid="physics.module.sourcepath"/>
+                <src path= "C:/Users/Sam/workspace2/jmephysics/src"/>
+           </javac>
+
+           <copy todir="${physics.output.dir}">
+               <fileset dir="${module.physics.basedir}/src">
+                   <patternset refid="compiler.resources"/>
+                   <type type="file"/>
+               </fileset>
+           </copy>
+       </target>
+
+       <target name="compile.module.physics.tests" depends="compile.module.physics.production"
+               description="compile module physics; test classes" unless="skip.tests"> <!--depends="compile.module.jme"-->
+           <mkdir dir="${physics.testoutput.dir}"/>
+           <javac destdir="${physics.testoutput.dir}" debug="${compiler.debug}" nowarn="${compiler.generate.no.warnings}"
+                  memoryMaximumSize="${compiler.max.memory}" fork="true">
+               <compilerarg line="${compiler.args.physics}"/>
+               <classpath refid="physics.module.classpath"/>
+               <classpath location="${physics.output.dir}"/>
+               <src refid="physics.module.test.sourcepath"/>
+           </javac>
+
+           <copy todir="${physics.testoutput.dir}">
+               <fileset dir="${module.physics.basedir}/test">
+                   <patternset refid="compiler.resources"/>
+                   <type type="file"/>
+               </fileset>
+               <fileset dir="${module.physics.basedir}/test-interactive">
+                   <patternset refid="compiler.resources"/>
+                   <type type="file"/>
+               </fileset>
+           </copy>
+       </target>
+
+       <target name="release.module.physics" depends="compile.module.physics.production, javadoc.module.physics">
+           <mkdir dir="${physics.release.dir}"/>
+           <jar jarfile="${physics.release.dir}/jme-physics.jar" basedir="${physics.output.dir}" update="no"
+                compress="true"
+                includes="**">
+               <manifest>
+                   <attribute name="Implementation-Title" value="${name}"/>
+                   <attribute name="Implementation-Vendor" value="jME Physics development team"/>
+                   <attribute name="Version" value="2.1"/>
+                   <attribute name="Class-Path" value="jme.jar jmetest.jar jmetest-data.jar lib/lwjgl.jar lib/jinput.jar jme-awt.jar lib/odejava-jni.jar"/>
+                   <attribute name="Main-Class" value="com.jmetest.physics.TestChooser"/>
+               </manifest>
+           </jar>
+           <zip zipfile="${physics.release.dir}/jme-physics-src.zip">
+               <zipfileset dir=".">
+                   <include name="**/*.java"/>
+               </zipfileset>
+           </zip>
+           <zip zipfile="${physics.release.dir}/jme-physics-doc.zip">
+               <zipfileset dir="${physics.javadoc.dir}">
+                   <include name="**"/>
+               </zipfileset>
+           </zip>
+       </target>
+
+       <target name="javadoc.module.physics">
+           <javadoc destdir="${physics.javadoc.dir}" windowtitle="${name} API" use="true"
+                    doctitle="${name}" classpathref="physics.module.classpath" source="1.5" failonerror="true">
+               <packageset dir="${module.physics.basedir}/src" defaultexcludes="yes">
+                   <include name="**" />
+               </packageset>
+           </javadoc>
+       </target>
+
+       <target name="clean.module.physics" description="cleanup module">
+           <delete dir="${physics.output.dir}"/>
+           <delete dir="${physics.testoutput.dir}"/>
+       </target>
+       
+        <property name="module.physics.ode.basedir" location="impl/ode"/>
+
+
+           <property name="compiler.args.physics.ode" value="${compiler.args}"/>
+
+           <property name="physics.ode.output.dir" value="${module.physics.ode.basedir}/classes"/>
+           <property name="physics.ode.testoutput.dir" value="${module.physics.ode.basedir}/classes"/>
+
+           <path id="physics.ode.module.bootclasspath">
+               <!-- Paths to be included in compilation bootclasspath -->
+           </path>
+
+           <path id="physics.ode.module.classpath">
+               <pathelement location="${module.physics.ode.basedir}/lib/odejava-jni.jar"/>
+               <pathelement location="${physics.output.dir}"/>
+               <pathelement location="${jme.output.dir}"/>
+               <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/jogg-0.0.5.jar"/>
+               <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/lwjgl.jar"/>
+               <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/jorbis-0.0.12.jar"/>
+               <pathelement location="${module.physics.ode.basedir}/../../../jME/lib/lwjgl_fmod3.jar"/>
+               <path refid="library.junit.classpath"/>
+           </path>
+
+
+           <patternset id="excluded.from.module.physics.ode">
+               <patternset refid="ignored.files"/>
+           </patternset>
+
+           <patternset id="excluded.from.compilation.physics.ode">
+               <patternset refid="excluded.from.module.physics.ode"/>
+           </patternset>
+
+           <path id="physics.ode.module.sourcepath">
+               <dirset dir="${module.physics.ode.basedir}">
+                   <include name="src"/>
+               </dirset>
+           </path>
+
+
+           <target name="compile.module.physics.ode"
+                   depends="compile.module.physics.ode.production,compile.module.physics.ode.tests"
+                   description="Compile module physics.ode"/>
+
+           <target name="compile.module.physics.ode.production" 
+                   description="Compile module physics.ode; production classes">
+               <mkdir dir="${physics.ode.output.dir}"/>
+               <javac destdir="${physics.ode.output.dir}" debug="${compiler.debug}" nowarn="${compiler.generate.no.warnings}"
+                      memoryMaximumSize="${compiler.max.memory}" fork="true">
+                   <compilerarg line="${compiler.args.physics.ode}"/>
+                   <bootclasspath refid="physics.ode.module.bootclasspath"/>
+                   <classpath refid="physics.ode.module.classpath"/>
+                   <src refid="physics.ode.module.sourcepath"/>
+               </javac>
+
+               <copy todir="${physics.ode.output.dir}">
+                   <fileset dir="${module.physics.ode.basedir}/src">
+                       <patternset refid="compiler.resources"/>
+                       <type type="file"/>
+                   </fileset>
+               </copy>
+           </target>
+
+           <target name="release.module.physics.ode" depends="compile.module.physics.ode.production, release.module.physics">
+               <jar jarfile="${physics.release.dir}/jme-physics.jar" basedir="${physics.ode.output.dir}" update="yes"
+                    compress="true"
+                    includes="**"/>
+               <mkdir dir="${physics.release.dir}/lib"/>
+               <copy todir="${physics.release.dir}/lib">
+                   <fileset dir="${module.physics.ode.basedir}/lib">
+                       <include name="*.dll"/>
+                       <include name="*.so"/>
+                       <include name="*.*lib"/>
+                       <include name="*.jar"/>
+                   </fileset>
+               </copy>
+           </target>
+
+           <target name="compile.module.physics.ode.tests" depends="compile.module.physics.ode.production"
+                   description="compile module physics.ode; test classes" unless="skip.tests"/>
+
+           <target name="clean.module.physics.ode" description="cleanup module">
+               <delete dir="${physics.ode.output.dir}"/>
+               <delete dir="${physics.ode.testoutput.dir}"/>
+           </target>
 </project>
\ No newline at end of file
Index: impl/ode/src/org/odejava/JointGroup.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/JointGroup.java,v
retrieving revision 1.6
diff -u -r1.6 JointGroup.java
--- impl/ode/src/org/odejava/JointGroup.java    9 Mar 2007 18:41:36 -0000   1.6
+++ impl/ode/src/org/odejava/JointGroup.java    11 Jul 2009 22:23:55 -0000
@@ -27,8 +27,10 @@
  */
 package org.odejava;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedList;
+import java.util.List;
 
 import org.odejava.ode.Ode;
 import org.odejava.ode.SWIGTYPE_p_dJointGroupID;
@@ -46,6 +48,8 @@
  *         see http://odejava.dev.java.net
  */
 public class JointGroup {
+   private static final List<SWIGTYPE_p_dJointGroupID> jointGroups = new ArrayList<SWIGTYPE_p_dJointGroupID>();
+   
     private SWIGTYPE_p_dJointGroupID jointGroupId;
     protected LinkedList<Joint> jointList;
 
@@ -58,6 +62,7 @@
     public JointGroup( String name, int max_size ) {
         jointGroupId = Ode.dJointGroupCreate( max_size );
         jointList = new LinkedList<Joint>();
+        jointGroups.add(jointGroupId);
         // jointMap = new HashMap();
     }
 
@@ -122,6 +127,17 @@
     public void delete() {
         empty();
         Ode.dJointGroupDestroy( jointGroupId );
+        jointGroups.remove(jointGroupId);
     }
 
+    /**
+     * Delete all collision groups that have not already been deleted.
+     */
+    public static void deleteAllJointGroups()
+    {
+       for (SWIGTYPE_p_dJointGroupID jointID:jointGroups)
+           Ode.dJointGroupDestroy(jointID);
+       jointGroups.clear();
+    }
+    
 }
Index: impl/ode/src/org/odejava/Geom.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/Geom.java,v
retrieving revision 1.12
diff -u -r1.12 Geom.java
--- impl/ode/src/org/odejava/Geom.java  2 Dec 2007 17:35:16 -0000   1.12
+++ impl/ode/src/org/odejava/Geom.java  11 Jul 2009 22:23:55 -0000
@@ -27,6 +27,7 @@
  */
 package org.odejava;
 
+import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
 import java.util.HashMap;
 import java.util.Map;
@@ -111,11 +112,14 @@
      */
     private PhysicsCollisionGeometry geometry;
 
+    /*
+     * THIS is holding onto data when it shouldn't be.
+     */
     /**
      * Lookup map of Geoms to their native addresses.
      */
-    private static Map<MutableLong, WeakReference<Geom>> geomNativeAddr =
-            new HashMap<MutableLong, WeakReference<Geom>>();
+    public static Map<MutableLong, Reference<Geom>> geomNativeAddr =
+            new HashMap<MutableLong,Reference<Geom>>();
 
     private static MutableLong tmp_addess = new MutableLong();
 
@@ -166,11 +170,20 @@
     public void setCategoryBits( long bits ) {
         Ode.dGeomSetCategoryBits( geomId, bits );
     }
+    
+    public long getCategoryBits()
+    {
+       return Ode.dGeomGetCategoryBits(geomId);
+    }
 
     public void setCollideBits( long bits ) {
         Ode.dGeomSetCollideBits( geomId, bits );
     }
 
+    public long getCollideBits()
+    {
+       return Ode.dGeomGetCollideBits(geomId);
+    }
     /**
      * Returns the name of the Geom.
      *
@@ -206,9 +219,14 @@
         tmp_addess.value = nativeAddr;
         geomNativeAddr.remove( tmp_addess );
         // Odejava.odeLog.debug("dGeomDestory(geomId: " + geomId + ")");
+        
+       // SWIGTYPE_p_dSpaceID spaceID = Ode.dGeomGetSpace(geomId);
+       // Ode.dSpaceRemove(spaceID, geomId);
+       
+        
         Ode.dGeomDestroy( geomId );
         space = null;
-
+        
         deleted = true;
     }
 
@@ -263,7 +281,13 @@
         // contains native address instead of Swig C pointer values
         nativeAddr = Odejava.getNativeAddr( MySWIGTYPE_p_dGeomID.getCPtr( geomId ) );
 
-        geomNativeAddr.put( new MutableLong( nativeAddr ), new WeakReference<Geom>( this ) );
+        if(nativeAddr == 0)
+           throw new IllegalStateException("The native address does not exist");
+        
+        /*
+         * PROBLEM: Cant use weak references here, because sometimes there wont be any other reference to a geom...
+         */
+        geomNativeAddr.put( new MutableLong( nativeAddr ), new StrongReference<Geom>( this ) );
     }
 
     /**
@@ -276,13 +300,16 @@
      */
     public static Geom getGeomFromNativeAddr( long nativeAddress ) {
         tmp_addess.value = nativeAddress;
-        final WeakReference<Geom> ref = geomNativeAddr.get( tmp_addess );
+        final Reference<Geom> ref = geomNativeAddr.get( tmp_addess );
         Geom geom = ref != null ? ref.get() : null;
         if ( geom == null && nativeAddress != 0 ) {
-            throw new IllegalStateException( "Geom with native address 0x" + Long.toHexString( nativeAddress ) + " not found!" );
+           boolean isContained = geomNativeAddr.keySet().contains(nativeAddress);
+            throw new IllegalStateException( "Geom with native address 0x" + Long.toHexString( nativeAddress ) + " not found! Note: The address was contained is " + isContained );
         }
         return geom;
-    }
+    }//this question is: is the geom not being created, or is it being created and deleted. in the second case, how is it possible that the goem looses its address? 
+    //is there some way to prevent this from happening, wihtout causing a huge memory leak?
+    //perhaps require explicit releasing of geoms?
 
     /**
      * Native address can be used to compare against contact information values
Index: impl/ode/src/org/odejava/JointFeedback.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/JointFeedback.java,v
retrieving revision 1.3
diff -u -r1.3 JointFeedback.java
--- impl/ode/src/org/odejava/JointFeedback.java 22 Sep 2007 14:29:16 -0000  1.3
+++ impl/ode/src/org/odejava/JointFeedback.java 11 Jul 2009 22:23:55 -0000
@@ -43,6 +43,11 @@
 public class JointFeedback {
     dJointFeedback feedback = null;
 
+    public JointFeedback( ) {
+        this.feedback = new dJointFeedback();
+    }
+
+    
     public JointFeedback( dJointFeedback feedback ) {
         this.feedback = feedback;
     }
Index: impl/ode/src/org/odejava/World.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/World.java,v
retrieving revision 1.6
diff -u -r1.6 World.java
--- impl/ode/src/org/odejava/World.java 4 Aug 2007 08:49:43 -0000   1.6
+++ impl/ode/src/org/odejava/World.java 11 Jul 2009 22:23:56 -0000
@@ -27,15 +27,19 @@
  */
 package org.odejava;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
-import com.jme.math.Vector3f;
+import org.odejava.collision.Collision;
 import org.odejava.ode.Ode;
+import org.odejava.ode.SWIGTYPE_p_dJointID;
 import org.odejava.ode.SWIGTYPE_p_dWorldID;
 import org.odejava.ode.SWIGTYPE_p_float;
 
+import com.jme.math.Vector3f;
+
 /**
  * The world object is a container for rigid bodies and joints. Objects in
  * different worlds can not interact, for example rigid bodies from two
@@ -225,6 +229,7 @@
      */
     public void quickStep() {
         // Step world based on contact jointgroup information
+       
         Ode.dWorldQuickStep( worldId, stepSize );
     }
 
@@ -593,7 +598,7 @@
      * @param vel The speed at which objects should correct contact problems
      */
     public void setMaxCorrectionVelocity( float vel ) {
-//        Ode.dWorldSetContactMaxCorrectingVel(worldId, vel);
+       Ode.dWorldSetContactMaxCorrectingVel(worldId, vel);
     }
 
     /**
@@ -603,7 +608,41 @@
      * @return The correction velocity set. No range limits
      */
     public float getMaxCorrectionVelocity() {
-        return 0;
-//        return Ode.dWorldGetContactMaxCorrectingVel(worldId);
+     //   return 0;
+      return Ode.dWorldGetContactMaxCorrectingVel(worldId);
     }
+
+    /**
+     * Completely clear this world of all the ODE objects it contains (releasing their memory in the process).
+     * This world may then be reused by a future physics simulation. (The world itself is not deleted)
+     */
+   public void clear() {
+          if(getBodies() != null)
+          {
+              ArrayList<SWIGTYPE_p_dJointID> jointList = new ArrayList<SWIGTYPE_p_dJointID>();
+              for(Body body:getBodies())
+              {
+                  jointList.clear();
+                  body.getJoints(jointList);
+                  for( SWIGTYPE_p_dJointID jointID:jointList)
+                  {
+                      Ode.dJointDestroy(jointID);
+           
+                  }        
+       
+              }
+              
+
+       
+          
+     
+           getBodies().clear();
+          }
+        Collision.deleteAllContacts();
+        JointGroup.deleteAllJointGroups();
+        
+        //This is CRITICALLY imprtant to fix memory leaks!
+        Geom.geomNativeAddr.clear();
+       
+   }
 }
Index: impl/ode/src/org/odejava/Joint.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/org/odejava/Joint.java,v
retrieving revision 1.6
diff -u -r1.6 Joint.java
--- impl/ode/src/org/odejava/Joint.java 18 Oct 2007 14:40:56 -0000  1.6
+++ impl/ode/src/org/odejava/Joint.java 11 Jul 2009 22:23:55 -0000
@@ -209,6 +209,11 @@
         }
     }
 
+    public void setFeedbackTracker(JointFeedback feedback)
+    {
+       this.feedback = feedback;
+    }
+    
     /**
      * Check to see if feedback tracking is currently enabled.
      *
Index: src/com/jmex/physics/CollisionGroup.java
===================================================================
RCS file: /cvs/jmephysics/src/com/jmex/physics/CollisionGroup.java,v
retrieving revision 1.2
diff -u -r1.2 CollisionGroup.java
--- src/com/jmex/physics/CollisionGroup.java    17 Mar 2008 08:47:54 -0000  1.2
+++ src/com/jmex/physics/CollisionGroup.java    11 Jul 2009 22:23:56 -0000
@@ -86,10 +86,10 @@
     }
 
     public void delete() {
-        if ( numNodes > 0 ) {
+     /*   if ( numNodes > 0 ) {
             throw new IllegalStateException( "Cannot delete a collision group which contains nodes. " +
                     "Move nodes to another group first." );
-        }
+        }*/
         for ( CollisionGroup group : new ArrayList<CollisionGroup>( getCollidesWith() ) ) {
             collidesWith( group, false );
         }
Index: src/com/jmex/physics/PhysicsCollisionGeometry.java
===================================================================
RCS file: /cvs/jmephysics/src/com/jmex/physics/PhysicsCollisionGeometry.java,v
retrieving revision 1.18
diff -u -r1.18 PhysicsCollisionGeometry.java
--- src/com/jmex/physics/PhysicsCollisionGeometry.java  7 Feb 2008 18:05:41 -0000   1.18
+++ src/com/jmex/physics/PhysicsCollisionGeometry.java  11 Jul 2009 22:23:56 -0000
@@ -225,7 +225,7 @@
      * @see PhysicsNode#setMaterial
      */
     public void setMaterial( final Material value ) {
-        if ( value == null || value == getPhysicsNode().getMaterial() ) {
+        if ( value == null || (getPhysicsNode() != null && value == getPhysicsNode().getMaterial() )) {
             this.material = null;
         }
         else {
Index: src/com/jmex/physics/PhysicsDebugger.java
===================================================================
RCS file: /cvs/jmephysics/src/com/jmex/physics/PhysicsDebugger.java,v
retrieving revision 1.20
diff -u -r1.20 PhysicsDebugger.java
--- src/com/jmex/physics/PhysicsDebugger.java   30 Apr 2008 14:50:34 -0000  1.20
+++ src/com/jmex/physics/PhysicsDebugger.java   11 Jul 2009 22:23:56 -0000
@@ -64,10 +64,10 @@
      * @param renderer where to draw
      */
     public static void drawPhysics( PhysicsSpace space, Renderer renderer ) {
-        for ( PhysicsNode physicsNode : space.getNodes() ) {
+        for ( PhysicsNode physicsNode : space.getNodes().toArray(new PhysicsNode[0]) ) {
             drawPhysics( physicsNode, renderer );
         }
-        for ( Joint joint : space.getJoints() ) {
+        for ( Joint joint : space.getJoints().toArray(new Joint[0]) ) {
             drawJoint( joint, renderer );
         }
         space.drawImplementationSpecificPhysics( renderer );
Index: src/com/jmex/physics/material/Material.java
===================================================================
RCS file: /cvs/jmephysics/src/com/jmex/physics/material/Material.java,v
retrieving revision 1.19
diff -u -r1.19 Material.java
--- src/com/jmex/physics/material/Material.java 30 Apr 2008 14:50:33 -0000  1.19
+++ src/com/jmex/physics/material/Material.java 11 Jul 2009 22:23:57 -0000
@@ -56,18 +56,22 @@
  * @see com.jmex.physics.PhysicsNode#setMaterial(Material)
  */
 public class Material implements Savable {
-    public static final Material IRON = new Material( "iron" );
-    public static final Material WOOD = new Material( "wood" );
-    public static final Material CONCRETE = new Material( "concrete" );
-    public static final Material GRANITE = new Material( "granite" );
-    public static final Material GLASS = new Material( "glass" );
-    public static final Material PLASTIC = new Material( "plastic" );
-    public static final Material RUBBER = new Material( "rubber" );
-    public static final Material ICE = new Material( "ice" );
-    public static final Material DEFAULT = new Material( "default" );
-    public static final Material GHOST = new Material( "ghost" );
-    public static final Material OSMIUM = new Material( "osmium" );
-    public static final Material SPONGE = new Material( "sponge" );
+
+    public static final Material IRON = new Material( "iron",1 );
+    public static final Material WOOD = new Material( "wood",2 );
+    public static final Material CONCRETE = new Material( "concrete",3 );
+    public static final Material GRANITE = new Material( "granite",4 );
+    public static final Material GLASS = new Material( "glass",5 );
+    public static final Material PLASTIC = new Material( "plastic",6 );
+    public static final Material RUBBER = new Material( "rubber",7 );
+    public static final Material ICE = new Material( "ice",8 );
+    public static final Material DEFAULT = new Material( "default",-1 );
+    public static final Material GHOST = new Material( "ghost",9 );
+    public static final Material OSMIUM = new Material( "osmium",10 );
+    public static final Material SPONGE = new Material( "sponge",11 );
+    
+    
+    
     
     private static final ArrayList<Material> commonMaterials = new ArrayList<Material>();
 
@@ -220,6 +224,7 @@
 
         info.setApplied( false );
         GHOST.putContactHandlingDetails( null, info );
+        GHOST.setDensity(Float.MIN_VALUE);
         info.setApplied( true );
         
         commonMaterials.add(IRON);
@@ -236,6 +241,8 @@
         commonMaterials.add(SPONGE);
     }
 
+    private final Integer ID;
+    
     private String name;
 
     /**
@@ -261,6 +268,13 @@
      */
     public Material( String name ) {
         this.name = name;
+        this.ID = (int) Math.random()*Integer.MAX_VALUE;
+    }
+    
+    public Material(String name, int ID)
+    {
+        this.name = name;
+        this.ID = ID;
     }
 
     /**
@@ -269,6 +283,21 @@
     public Material() {
         this( null );
     }
+    
+     /**
+         * Construct a deep copy of the provided material
+         * @param toCopy
+         */
+        public Material(String name, Material toCopy)
+        {
+           this(name,toCopy.ID);
+      
+           this.debugColor = new ColorRGBA(toCopy.debugColor);
+           this.contactDetails = new HashMap(toCopy.contactDetails);
+           this.density = toCopy.density;
+           this.springPenetrationDepth = toCopy.springPenetrationDepth;
+           this.surfaceMotion = new Vector3f(toCopy.surfaceMotion);
+        }
 
     /**
      * Density of this material. Default is 1.
@@ -330,7 +359,7 @@
     /**
      * Map from Material to ContactHandlingDetails
      */
-    private Map<Material, ContactHandlingDetails> contactDetails;
+    private Map<Integer, ContactHandlingDetails> contactDetails;
 
     private static final Vector2f tmpV2 = new Vector2f();
     private static final Vector2f tmpV22 = new Vector2f();
@@ -342,7 +371,7 @@
      * @return contact details if
      */
     public ContactHandlingDetails getContactHandlingDetails( Material contactMaterial ) {
-        ContactHandlingDetails details = contactDetails != null ? contactDetails.get( contactMaterial ) : null;
+        ContactHandlingDetails details = contactDetails != null ? contactDetails.get( contactMaterial.ID ) : null;
         if ( details == null && contactMaterial != null ) {
             // use default contact details
             details = contactDetails != null ? contactDetails.get( null ) : null;
@@ -428,9 +457,9 @@
 
     private void putInternal( Material contactMaterial, ContactHandlingDetails details ) {
         if ( contactDetails == null ) {
-            contactDetails = new HashMap<Material, ContactHandlingDetails>();
+            contactDetails = new HashMap<Integer, ContactHandlingDetails>();
         }
-        contactDetails.put( contactMaterial, details );
+        contactDetails.put(contactMaterial != null ? contactMaterial.ID:null, details );
     }
 
     private Vector3f surfaceMotion;
@@ -544,10 +573,66 @@
        
         capsule.write(getName(), NAME_PROPERTY, null);
         capsule.write(getDensity(), DENSITY_PROPERTY, 1.0f);
-        capsule.writeSavableMap(contactDetails, CONTACT_HANDLING_DETAILS_PROPERTY, null);
+       // capsule.writeSavableMap(contactDetails, CONTACT_HANDLING_DETAILS_PROPERTY, null);
         capsule.write(getSurfaceMotion( null ), SURFACE_MOTION_PROPERTY, Vector3f.ZERO );
         capsule.write(getSpringPenetrationDepth(), SPRING_PENETRATION_DEPTH_PROPERTY, 0.0f);
    }
+
+   public Integer getID() {
+       return ID;
+   }
+
+   @Override
+   public int hashCode() {
+       final int prime = 31;
+       int result = 1;
+       result = prime * result + ((ID == null) ? 0 : ID.hashCode());
+       result = prime * result + Float.floatToIntBits(density);
+       result = prime * result + Float.floatToIntBits(springPenetrationDepth);
+       result = prime * result
+               + ((surfaceMotion == null) ? 0 : surfaceMotion.hashCode());
+       return result;
+   }
+
+   @Override
+   public boolean equals(Object obj) {
+       if (this == obj)
+           return true;
+       if (obj == null)
+           return false;
+       if (getClass() != obj.getClass())
+           return false;
+       final Material other = (Material) obj;
+       if (ID == null) {
+           if (other.ID != null)
+               return false;
+       } else if (!ID.equals(other.ID))
+           return false;
+       if (Float.floatToIntBits(density) != Float
+               .floatToIntBits(other.density))
+           return false;
+       if (Float.floatToIntBits(springPenetrationDepth) != Float
+               .floatToIntBits(other.springPenetrationDepth))
+           return false;
+       if (surfaceMotion == null) {
+           if (other.surfaceMotion != null)
+               return false;
+       } else if (!surfaceMotion.equals(other.surfaceMotion))
+           return false;
+       return true;
+   }
+
+   public Map<Integer, ContactHandlingDetails> getContactDetails() {
+       return contactDetails;
+   }
+
+   public void setContactDetails(
+           Map<Integer, ContactHandlingDetails> contactDetails) {
+       this.contactDetails = contactDetails;
+   }
+
+   
+   
 }
 
 /*
Index: src/com/jmex/physics/contact/PendingContact.java
===================================================================
RCS file: /cvs/jmephysics/src/com/jmex/physics/contact/PendingContact.java,v
retrieving revision 1.12
diff -u -r1.12 PendingContact.java
--- src/com/jmex/physics/contact/PendingContact.java    30 Apr 2008 14:50:33 -0000  1.12
+++ src/com/jmex/physics/contact/PendingContact.java    11 Jul 2009 22:23:56 -0000
@@ -45,7 +45,9 @@
 public abstract class PendingContact extends MutableContactInfo implements CompleteContactInfo {
 
     private static final Vector3f tmpVelocity = new Vector3f();
-
+    private static final Vector3f tmpAngularVelocity = new Vector3f();
+    private static final Vector3f tmpContactPosition = new Vector3f();
+    private static final Vector3f tmpDistance = new Vector3f();
     public Vector3f getContactVelocity( Vector3f store ) {
         if ( store == null ) {
             store = new Vector3f();
@@ -53,16 +55,27 @@
         computeContactVelocity( this, store );
         return store;
     }
-
+    //this doesnt include the angular velocity component!
     public static void computeContactVelocity( ContactInfo pendingContact, Vector3f store ) {
         Vector3f actualBounceVel = store.set( 0, 0, 0 );
+        Vector3f contactPosition = pendingContact.getContactPosition(tmpContactPosition);
         if ( pendingContact.getNode1() instanceof DynamicPhysicsNode ) {
             actualBounceVel.subtractLocal( ( (DynamicPhysicsNode) pendingContact.getNode1() )
                     .getLinearVelocity( tmpVelocity ) );
+            
+            ( (DynamicPhysicsNode) pendingContact.getNode1() ).getAngularVelocity(tmpAngularVelocity);
+           contactPosition.subtract(pendingContact.getNode1().getWorldTranslation(),tmpDistance);
+           actualBounceVel.subtractLocal( tmpAngularVelocity.crossLocal(tmpDistance));//add in the angular velocity component of node 1
+           
         }
         if ( pendingContact.getNode2() instanceof DynamicPhysicsNode ) {
             actualBounceVel.addLocal( ( (DynamicPhysicsNode) pendingContact.getNode2() )
-                    .getLinearVelocity( tmpVelocity ) );
+                    .getLinearVelocity( tmpVelocity ) );            
+            
+            ( (DynamicPhysicsNode) pendingContact.getNode2() ).getAngularVelocity(tmpAngularVelocity);
+            contactPosition.subtract(pendingContact.getNode2().getWorldTranslation(),tmpDistance);
+            actualBounceVel.addLocal( tmpAngularVelocity.crossLocal(tmpDistance));//add in the angular velocity component of node 1
+            
         }
         pendingContact.getContactNormal( tmpVelocity );
         float lengthSqr = actualBounceVel.dot( tmpVelocity );
Index: impl/ode/src/com/jmex/physics/impl/ode/DynamicPhysicsNodeImpl.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/com/jmex/physics/impl/ode/DynamicPhysicsNodeImpl.java,v
retrieving revision 1.30
diff -u -r1.30 DynamicPhysicsNodeImpl.java
--- impl/ode/src/com/jmex/physics/impl/ode/DynamicPhysicsNodeImpl.java  20 Mar 2008 07:50:01 -0000  1.30
+++ impl/ode/src/com/jmex/physics/impl/ode/DynamicPhysicsNodeImpl.java  11 Jul 2009 22:23:54 -0000
@@ -34,8 +34,13 @@
 
 import java.io.IOException;
 import java.util.List;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Logger;
 
+import org.odejava.Body;
+import org.odejava.GeomTransform;
+import org.odejava.PlaceableGeom;
+
 import com.jme.math.Quaternion;
 import com.jme.math.Vector3f;
 import com.jme.scene.Node;
@@ -47,15 +52,14 @@
 import com.jmex.physics.PhysicsSpace;
 import com.jmex.physics.PhysicsUpdateCallback;
 import com.jmex.physics.impl.ode.geometry.OdeGeometry;
-import org.odejava.Body;
-import org.odejava.GeomTransform;
-import org.odejava.PlaceableGeom;
 
 /**
  * @author Irrisor
  */
 public class DynamicPhysicsNodeImpl extends DynamicPhysicsNode implements OdePhysicsNode {
 
+   //public static ReentrantLock PHYSICSLOCK= null;
+   
     private final Body body;
 
     public Body getBody() {
@@ -134,6 +138,7 @@
                 rest();
                 for ( int i = body.getGeoms().size() - 1; i >= 0; i-- ) {
                     PlaceableGeom geom = body.getGeoms().get( i );
+                    
                     odePhysicsSpace.removeGeom( geom, getCollisionGroup() );
                 }
             }
@@ -214,7 +219,10 @@
     public void updateWorldVectors() {
         super.updateWorldVectors();
         //TODO: only if necessary!
-        sceneToOde();
+     // if(PHYSICSLOCK.isHeldByCurrentThread())//this will have performance impacts likely.
+           sceneToOde();
+     // else
+      //   Logger.getLogger(PhysicsSpace.LOGGER_NAME).warning("Access to physics node denied.");
     }
 
 //    private boolean odeEnabled = true;
@@ -224,8 +232,11 @@
         {
             body.setEnabled( true );
             enabled = true;
+            
             body.setPosition( localToWorld( centerOfMass, tmpPosition ) );
             body.setQuaternion( getWorldRotation() );
+            
+   
         }
         else
         {
@@ -237,6 +248,8 @@
     private boolean checkODESceneSync() {
         body.getPosition( odePos );
         body.getQuaternion( odeRot );
+      //  if(odeRot.w == 0)
+      //   System.out.println("zero quat");
         //todo: is this too expensive to be worth it? (localToWorld vs. worldToLocal)
         boolean odeAndSceneInSync = getWorldRotation().equals( odeRot )
                 && localToWorld( centerOfMass, tmpPosition ).equals( odePos );
@@ -252,11 +265,25 @@
                 Logger.getLogger( PhysicsSpace.LOGGER_NAME ).warning( "ODE transform result was NaN for node " + this
                         + " trying to recover..." );
                 // with this position something went really wrong - move it a little bit
-                System.err.println( getLocalTranslation() );
-                System.err.println( getLocalRotation() );
-                getLocalTranslation().x *= 1.0001f;
-                getLocalTranslation().y *= 1.0001f;
-                getLocalTranslation().z *= 1.0001f;
+               // System.err.println( getLocalTranslation() );
+              //  System.err.println( getLocalRotation() );
+             //   System.out.println(this.getForce(null) + "\t" + this.getTorque(null));
+                getLocalTranslation().x +=( Math.random()>0.5f) ? 0.001f:-0.001f;
+                getLocalTranslation().y +=( Math.random()>0.5f) ? 0.001f:-0.001f;
+                getLocalTranslation().z +=( Math.random()>0.5f) ? 0.001f:-0.001f;
+              
+                
+                //;wtl(odePos-centerOfMass) = localTra
+                
+           //     Vector3f oldODEPos = this.localToWorld( getLocalTranslation(), new Vector3f()).addLocal(centerOfMass);
+             //   body.setPosition(oldODEPos);
+             //   System.out.println(oldODEPos);
+                //body.setPosition( new Vector3f(1,1,1) );
+               // body.getQuaternion( odeRot );
+                
+              //  this.updateWorldTranslation();
+             //  System.out.println(this.getChildren());
+            //    updateWorldTranslation();
                 // most likely velocities and/or forces are broken as well - reset them
                 clearDynamics();
                 return;
@@ -266,13 +293,30 @@
             // thus the local translation still needs to be computed from that
             worldRotation.set( odeRot );
             worldTranslation.set( 0, 0, 0 );
-            localToWorld( centerOfMass, tmpPosition );
+            localToWorldB( centerOfMass, tmpPosition );
             tmpPosition.multLocal( -1 ).addLocal( odePos );
             space.worldToLocal( this, tmpPosition, getLocalTranslation() );
+            //updateWorldTranslation();
+       
         }
     }
 
 
+    /**
+     * Get in world coords without considering the world translation
+     * @param in
+     * @param store
+     * @return
+     */
+    private Vector3f localToWorldB(Vector3f in, Vector3f store)
+    {
+        if ( store == null ) store = new Vector3f();
+            // multiply with scale first, then rotate, finally translate (cf. Eberly)
+        return getWorldRotation().mult(store.set( in ).multLocal( getWorldScale() ),
+               store );
+        
+    }
+    
     @Override
     public void addForce( Vector3f force, Vector3f at ) {
         body.setEnabled( true );
@@ -422,12 +466,17 @@
 
     private Boolean enabled;
 
-    public boolean isResting() {
+    public  boolean isResting() {
         if ( enabled == null )
         {
             enabled = body.isEnabled();
         }
-        return !enabled;
+       try{
+          return !enabled;//possible multithreaded error here...
+       }catch(NullPointerException e)
+        {
+           return false;
+        }
     }
 
     @Override
@@ -446,6 +495,7 @@
     @Override
     protected void finalize() throws Throwable {
         super.finalize();
+      //  System.out.println("Finallizing physics body");
         space.deleteBody( body );
     }
 
Index: impl/ode/src/com/jmex/physics/impl/ode/OdeCollisionGroup.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/com/jmex/physics/impl/ode/OdeCollisionGroup.java,v
retrieving revision 1.2
diff -u -r1.2 OdeCollisionGroup.java
--- impl/ode/src/com/jmex/physics/impl/ode/OdeCollisionGroup.java   17 Mar 2008 08:47:48 -0000  1.2
+++ impl/ode/src/com/jmex/physics/impl/ode/OdeCollisionGroup.java   11 Jul 2009 22:23:54 -0000
@@ -31,11 +31,12 @@
  */
 package com.jmex.physics.impl.ode;
 
+import org.odejava.HashSpace;
+import org.odejava.Space;
+
 import com.jmex.physics.CollisionGroup;
 import com.jmex.physics.PhysicsNode;
 import com.jmex.physics.PhysicsSpace;
-import org.odejava.HashSpace;
-import org.odejava.Space;
 
 public class OdeCollisionGroup extends CollisionGroup {
     private Space odeSpace = new HashSpace();
Index: impl/ode/src/com/jmex/physics/impl/ode/OdePhysicsSpace.java
===================================================================
RCS file: /cvs/jmephysics/impl/ode/src/com/jmex/physics/impl/ode/OdePhysicsSpace.java,v
retrieving revision 1.43
diff -u -r1.43 OdePhysicsSpace.java
--- impl/ode/src/com/jmex/physics/impl/ode/OdePhysicsSpace.java 30 Apr 2008 14:50:27 -0000  1.43
+++ impl/ode/src/com/jmex/physics/impl/ode/OdePhysicsSpace.java 11 Jul 2009 22:23:55 -0000
@@ -32,12 +32,26 @@
 
 package com.jmex.physics.impl.ode;
 
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import org.odejava.Body;
+import org.odejava.Geom;
+import org.odejava.GeomRay;
+import org.odejava.JointFeedback;
+import org.odejava.Odejava;
+import org.odejava.PlaceableGeom;
+import org.odejava.World;
+import org.odejava.collision.Contact;
+import org.odejava.collision.JavaCollision;
+import org.odejava.ode.Ode;
+import org.odejava.ode.OdeConstants;
+
 import com.jme.math.FastMath;
 import com.jme.math.Quaternion;
 import com.jme.math.Vector2f;
@@ -73,22 +87,12 @@
 import com.jmex.physics.impl.ode.geometry.OdeRay;
 import com.jmex.physics.impl.ode.geometry.OdeSphere;
 import com.jmex.physics.impl.ode.joints.OdeJoint;
-import org.odejava.Body;
-import org.odejava.Geom;
-import org.odejava.GeomRay;
-import org.odejava.Odejava;
-import org.odejava.PlaceableGeom;
-import org.odejava.World;
-import org.odejava.collision.Contact;
-import org.odejava.collision.JavaCollision;
-import org.odejava.ode.Ode;
-import org.odejava.ode.OdeConstants;
 
 /**
  * @author Irrisor
  */
 public class OdePhysicsSpace extends PhysicsSpace {
-    private PendingContact contact = new PendingContact() {
+    private PendingContact contact = new OdePendingContact() {
         public Vector3f getContactNormal( Vector3f store ) {
             if ( store == null ) {
                 store = new Vector3f();
@@ -123,12 +127,18 @@
             return odeContact.getDepth();
         }
 
+        public void enableJointFeedback(JointFeedback feedback)
+        {
+           odeContact.enableFeedback(feedback);
+        }
+        
         public void getDefaultFrictionDirections( Vector3f primaryStore, Vector3f secondaryStore ) {
             Vector3f n = getContactNormal( tmp2 );
             computeODEDefaultFrictionDirection( n, primaryStore, secondaryStore );
         }
 
         public float getTime() {
+        
             return timeSinceStartOfUpdate;
         }
     };
@@ -288,11 +298,24 @@
     private World world;
 
     private OdeCollisionGroup defaultCollisionGroup;
-    private OdeCollisionGroup staticCollisionGroup;
+    public OdeCollisionGroup getDefaultCollisionGroup() {
+       return defaultCollisionGroup;
+   }
 
-    // collision system
+   private OdeCollisionGroup staticCollisionGroup;
+
+    public OdeCollisionGroup getStaticCollisionGroup() {
+       return staticCollisionGroup;
+   }
+
+   // collision system
     private JavaCollision collision;
 
+    public void setMaxStepContactsPerNearcallback(int maxContacts)
+    {
+       collision.setMaxStepContactsPerNearcallback(maxContacts);
+    }
+    
     // helper class to read/write collisional data
     private Contact odeContact;
 
@@ -416,7 +439,17 @@
             return;
         }
         super.removeNode( obj );
-
+     
+/*        if (obj instanceof DynamicPhysicsNodeImpl)
+        {
+           DynamicPhysicsNodeImpl odeNode = (DynamicPhysicsNodeImpl) obj;
+           for (PlaceableGeom geom: odeNode.getBody().getGeoms().toArray(new PlaceableGeom[]{}))
+               geom.delete();
+            this.world.deleteBody(odeNode.getBody());
+            
+        }*/
+       
+        
         // print out a statement
         Logger logger = Logger.getLogger( PhysicsSpace.LOGGER_NAME );
         if ( logger.isLoggable( Level.INFO ) ) {
@@ -460,7 +493,11 @@
                 "Changed the number of updates in a second of PhysicsWorld to: " + ups );
     }
 
-    /**
+    public World getWorld() {
+       return world;
+   }
+
+   /**
      * Returns how many updates per second we run at. Default is running as fast
      * as possible (-1).
      *
@@ -475,8 +512,17 @@
      * Temp variables to flatline memory usage.
      */
     private final Quaternion inverseWorldRotation = new Quaternion();
+   private SceneUpdateLock sceneUpdateLock;
 
-    /**
+    public SceneUpdateLock getSceneUpdateLock() {
+       return sceneUpdateLock;
+   }
+
+   public void setSceneUpdateLock(SceneUpdateLock sceneUpdateLock) {
+       this.sceneUpdateLock = sceneUpdateLock;
+   }
+
+   /**
      * Sets the world translation of a spatial according to a supplied body.
      * This is done by going "the other way around"; figuring
      * out what its local translation has to be in order for the world
@@ -530,6 +576,37 @@
         removeAllFromUpdateCallbacks();
         removeAllObjects();
         removeAllJoints();
+        this.appliedContacts = 0;
+        
+       
+        
+        world.clear();
+        
+        collision = new JavaCollision( world );
+        odeContact = new Contact( collision.getContactLongBuffer(), collision.getContactFloatBuffer() );
+   
+       usedContactInfo = null;
+        lastUsedContactInfo=null;
+     availableContactInfo= null;
+
+       usedContactInfo2= null;
+       lastUsedContactInfo2 = null;
+       availableContactInfo2 = null;
+  
+       getDefaultCollisionGroup().delete();
+       this.getStaticCollisionGroup().delete();
+
+       for(CollisionGroup g:this.getCollisionGroups().toArray(new CollisionGroup[0]))
+       {
+          g.delete();
+       }
+       staticCollisionGroup = createCollisionGroup( "static" );
+
+       defaultCollisionGroup = createCollisionGroup( "default" );
+       defaultCollisionGroup.collidesWith( defaultCollisionGroup, true );
+
+       defaultCollisionGroup.collidesWith( staticCollisionGroup, true );
+
     }
 
     public void pick( PhysicsSpatial spatial ) {
@@ -574,16 +651,20 @@
         elapsedTime += tpf;
 
 //        contactInfos.clear();
-
+       // updateRate = -1;
+   //  long num = 0;
         boolean updated = false;
         while ( elapsedTime >= updateRate ) {
+     //    num++;
+      //   long time[] = new long[6];
+       //  time[0] = System.nanoTime();
             if ( !updated ) {
                 reuseContactInfos(); //FIX ME: deactivate triggers using this infos? keep infos for active triggers?
                 for ( OdeJoint joint : joints ) {
                     joint.updateJointType();
                 }
             }
-
+       //     time[1] = System.nanoTime();
             // call update callbacks
             for ( int i = this.sizeOfUpdateCallbacks() - 1; i >= 0; i-- ) {
                 PhysicsUpdateCallback updateCallback = this.getFromUpdateCallbacks( i );
@@ -592,20 +673,34 @@
 //                }
                 updateCallback.beforeStep( this, world.getStepSize() );
             }
+        //    time[2] = System.nanoTime();
             updated = true;
 
             computeTimeStep();
-
+        //    time[3] = System.nanoTime();
+            
+        //    sceneUpdateLock();
+            try{
             if ( this.sizeOfUpdateCallbacks() > 0 ) {
                 updateScene();
             }
-
+            }finally
+            {
+         //    sceneUpdateUnlock();
+            }
+         //   time[4] = System.nanoTime();
             // call update callbacks
             for ( int i = this.sizeOfUpdateCallbacks() - 1; i >= 0; i-- ) {
                 PhysicsUpdateCallback updateCallback = this.getFromUpdateCallbacks( i );
                 updateCallback.afterStep( this, world.getStepSize() );
             }
-
+          //  time[5] = System.nanoTime();
+         /*   String times  = "Physics: ";
+           
+           for(int i = 1;i<time.length;i++)
+               times+="\t" + (time[i] - time[i-1]);
+           times += "\t" + num;
+           System.out.println(times );*/
             if ( updateRate > 0 ) {
                 elapsedTime -= updateRate;
                 timeSinceStartOfUpdate += updateRate;
@@ -630,10 +725,25 @@
         }
     }
 
-    public void pick( PhysicsCollisionGeometry geometry ) {
+    private void sceneUpdateLock() {
+       if(sceneUpdateLock != null)
+       {
+           sceneUpdateLock.lock();
+       }
+   }
+
+   private void sceneUpdateUnlock() {
+       if(sceneUpdateLock != null)
+       {
+           sceneUpdateLock.unlock();
+       }
+   }
+
+   public void pick( PhysicsCollisionGeometry geometry ) {
         OdeGeometry odeGeometry = (OdeGeometry) geometry;
-        for ( int i = 0; i < getCollisionGroups().size(); i++ ) {
-            OdeCollisionGroup group =  getCollisionGroups().get( i );
+        for ( int i = 0; i <geometry.getPhysicsNode().getCollisionGroup().getCollidesWith().size(); i++ ) {
+            OdeCollisionGroup group = (OdeCollisionGroup) geometry.getPhysicsNode().getCollisionGroup().getCollidesWith().get( i );
+            
             collision.collide2( group.getOdeSpace(), odeGeometry.getOdeGeom() );
             iterateContacts( false );
         }
@@ -820,6 +930,7 @@
     }
 
     private void updateScene() {
+       
         for ( int i = physicsNodes.size() - 1; i >= 0; i-- ) {
             PhysicsNode node = physicsNodes.get( i );
             ( (OdePhysicsNode) node ).sceneFromOde();
@@ -843,14 +954,17 @@
         PhysicsNode previous1 = null;
         PhysicsNode previous2 = null;
         int appliedContacts = this.appliedContacts;
+        try{
         for ( int i = 0; i < collision.getContactCount(); i++ ) {
             // set the index
+           
             odeContact.setIndex( i );
-
+      
             final Geom geom1 = odeContact.getGeom1();
             final Geom geom2 = odeContact.getGeom2();
             if ( geom1 == null || geom2 == null ) {
                 odeContact.ignoreContact();
+           
                 continue;
             }
             PhysicsNode obj1 = geom1.getPhysicsObject();
@@ -955,7 +1069,25 @@
                     }
                 }
             }
+        
         }
+           
+        }catch(IllegalStateException e)
+       {
+           //NOTE: it is possible, though uncommon, for this error to occur during a running physics game - as opposed to at the begining.
+           //
+           //what if this is a multithreaded error?
+           e.printStackTrace();
+              Logger.getLogger( PhysicsSpace.LOGGER_NAME ).log(Level.SEVERE,e.getMessage());
+   /*         this.appliedContacts = 0;
+              collision = new JavaCollision( world );
+               odeContact = new Contact( collision.getContactLongBuffer(), collision.getContactFloatBuffer() );*/
+        
+               throw e;
+               // The root cause of this is as yet unknown. It causes the physics to explode wildly at the beginning (possibly this has been mitigated). 
+                
+              
+       }
         this.appliedContacts = appliedContacts;
         return collision.getContactCount() > 0;
     }
@@ -987,25 +1119,25 @@
             return store;
         }
 
-        private PhysicsCollisionGeometry geometry1;
-        private PhysicsCollisionGeometry geometry2;
-        private PhysicsNode node1;
-        private PhysicsNode node2;
+        private Reference<PhysicsCollisionGeometry> geometry1;
+        private Reference<PhysicsCollisionGeometry> geometry2;
+        private Reference<PhysicsNode> node1;
+        private Reference<PhysicsNode> node2;
 
         public PhysicsCollisionGeometry getGeometry1() {
-            return geometry1;
+            return geometry1.get();
         }
 
         public PhysicsCollisionGeometry getGeometry2() {
-            return geometry2;
+            return geometry2.get();
         }
 
         public PhysicsNode getNode1() {
-            return node1;
+            return node1.get();
         }
 
         public PhysicsNode getNode2() {
-            return node2;
+            return node2.get();
         }
 
         private float depth;
@@ -1027,12 +1159,14 @@
             super.copy( info );
             info.getContactNormal( normal );
             info.getContactPosition( position );
-            geometry1 = info.getGeometry1();
-            geometry2 = info.getGeometry2();
-            node1 = info.getNode1();
-            node2 = info.getNode2();
+            geometry1 = new WeakReference<PhysicsCollisionGeometry> (info.getGeometry1());
+            geometry2 = new WeakReference<PhysicsCollisionGeometry> (info.getGeometry2());
+            node1 = new WeakReference<PhysicsNode>  (info.getNode1());
+            node2 =  new WeakReference<PhysicsNode> (info.getNode2());
             depth = info.getPenetrationDepth();
             time = info.getTime();
+            
+           //references can also stay alive through JME's collision manager cache.
         }
 
         @Override
@@ -1184,7 +1318,7 @@
     public void removeAllObjects() {
         @SuppressWarnings("unchecked")
         List<PhysicsNode> list = (List<PhysicsNode>) physicsNodes.clone();
-        for ( PhysicsNode node : list ) {
+        for ( PhysicsNode node : list.toArray(new PhysicsNode[]{}) ) {
             removeNode( node );
         }
     }
@@ -1292,8 +1426,51 @@
                     ColorRGBA.cyan, 3 );
         }
     }
+    
+    /**
+     * Set the amount of constant force to mix into the system when the bodies are not at a stop. This value has no effect when the bodies are at one of the two stops.
+
+
+     * @param cfm
+     */
+    public void setCFM(float cfm)
+    {
+       world.setConstraintForceMix(cfm);
+    }
+    
+    /**
+     * Set the amount of error reduction. This value should be between 0 and 1. 0 is no reduction at all, 1 is full correction in a single step.
+
+
+     * @param erp
+     */
+    public void setERP(float erp)
+    {
+       world.setErrorReductionParameter(erp);
+    }
+    
+    public float getCFM()
+    {
+       return world.getConstraintForceMix();
+    }
+    
+    public float getERP()
+    {
+       return world.getErrorReductionParameter();
+    }
+    public void setInteraction(int in)
+    {
+       world.setStepInteractions(in);
+    }
+    
+    public float getMaxVel()
+    {
+       return world.getMaxCorrectionVelocity();
+    }
+    
+    public void setMaxVel(float vel)
+    {
+       world.setMaxCorrectionVelocity(vel);
+    }
 }
 
-/*
-* $log$
-*/
Index: test-interactive/com/jmetest/physics/TestDomino.java
===================================================================
RCS file: /cvs/jmephysics/test-interactive/com/jmetest/physics/TestDomino.java,v
retrieving revision 1.6
diff -u -r1.6 TestDomino.java
--- test-interactive/com/jmetest/physics/TestDomino.java    26 Nov 2007 10:28:34 -0000  1.6
+++ test-interactive/com/jmetest/physics/TestDomino.java    11 Jul 2009 22:23:57 -0000
@@ -36,6 +36,8 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import org.odejava.Odejava;
+
 import com.jme.bounding.BoundingBox;
 import com.jme.bounding.BoundingSphere;
 import com.jme.image.Texture;
@@ -60,6 +62,7 @@
 
 public class TestDomino extends SimplePhysicsTest {
     protected void simpleInitGame() {
+       System.out.println(Odejava.getLibraryVersion());
         getPhysicsSpace().setAutoRestThreshold( 0.2f );
         setPhysicsSpeed( 4 );
 
Index: .classpath
===================================================================
RCS file: /cvs/jmephysics/.classpath,v
retrieving revision 1.5
diff -u -r1.5 .classpath
--- .classpath  10 Mar 2007 15:35:01 -0000  1.5
+++ .classpath  11 Jul 2009 22:23:54 -0000
@@ -2,20 +2,16 @@
 <classpath>
    <classpathentry kind="src" path="src"/>
    <classpathentry kind="src" path="impl/ode/src"/>
-   <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
-       <attributes>
-           <attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="jmephysics/impl/ode/lib"/>
-       </attributes>
-   </classpathentry>
+   <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
    <classpathentry kind="src" path="test"/>
    <classpathentry kind="src" path="test-interactive"/>
-   <classpathentry combineaccessrules="false" kind="src" path="/jme"/>
-   <classpathentry kind="lib" path="ant/lib/junit.jar">
+   <classpathentry kind="lib" path="impl/joode/lib/joode.jar"/>
+   <classpathentry kind="lib" path="ant/lib/junit.jar"/>
+   <classpathentry kind="lib" path="experimental/odejava-jni.jar">
        <attributes>
-           <attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="jmephysics/impl/ode/lib"/>
+           <attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="jmephysics/experimental"/>
        </attributes>
    </classpathentry>
-   <classpathentry kind="lib" path="impl/ode/lib/odejava-jni.jar"/>
-   <classpathentry kind="lib" path="impl/joode/lib/joode.jar"/>
+   <classpathentry combineaccessrules="false" kind="src" path="/jme"/>
    <classpathentry kind="output" path="classes"/>
 </classpath>
Index: src/com/jmex/physics/util/states/PhysicsMultithreadedGameState.java
===================================================================
RCS file: /cvs/jmephysics/src/com/jmex/physics/util/states/PhysicsMultithreadedGameState.java,v
retrieving revision 1.3
diff -u -r1.3 PhysicsMultithreadedGameState.java
--- src/com/jmex/physics/util/states/PhysicsMultithreadedGameState.java 22 Sep 2007 14:28:38 -0000  1.3
+++ src/com/jmex/physics/util/states/PhysicsMultithreadedGameState.java 11 Jul 2009 22:23:57 -0000
@@ -32,30 +32,57 @@
 
 package com.jmex.physics.util.states;
 
-import java.util.concurrent.locks.Lock;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import com.jme.scene.Node;
+import com.jme.system.DisplaySystem;
+import com.jme.util.NanoTimer;
 import com.jme.util.Timer;
-import com.jme.util.lwjgl.LWJGLTimer;
 import com.jmex.game.state.BasicGameState;
 import com.jmex.physics.PhysicsSpace;
 
 /**
  * <code>PhysicsGameState</code> provides physics encapsulation into a GameState.
- * 
+ * Note: PhysicsDebugger is NOT thread-safe.
  * @author Matthew D. Hicks
  */
 public class PhysicsMultithreadedGameState extends BasicGameState {
    private PhysicsSpace physics;
-   private PhysicsThread thread;
-   
+   private PhysicsThread physicsRunnable;
+   /**
+    * Keep a reference to this so that it can be shut down if necessary
+    */
+   private Thread thread;
+   /**
+    * This node should be the parent for all physics objects.
+    * It will be updated in the physics thread.
+    */
+   private Node physicsRoot;
+   
+   /**
+    * This node should be the parent for all physics objects.
+    * It will be updated in the physics thread.
+    * @return the root physics node.
+    */
+   public Node getPhysicsRoot() {
+       return physicsRoot;
+   }
+
    public PhysicsMultithreadedGameState(String name) {
+       this(name, 30);
+   }
+   
+   public PhysicsMultithreadedGameState(String name, int desiredUpdatesPerSecond) {
        super(name);
-       thread = new PhysicsThread(30);
-       physics = thread.getPhysics();
-       new Thread(thread).start();
+       physicsRunnable = new PhysicsThread(desiredUpdatesPerSecond);
+       physics = physicsRunnable.getPhysics();
+       physicsRoot = physicsRunnable.getPhysicsRoot();
+       thread = new Thread(null, physicsRunnable, "Physics Thread");
+       thread.start();
    }
    
    public PhysicsSpace getPhysicsSpace() {
@@ -64,118 +91,191 @@
    
    public void update(float tpf) {
        super.update(tpf);
-       if (!thread.isEnabled()) {
-           thread.setEnabled(true);
+       if (!physicsRunnable.isEnabled()) {
+           physicsRunnable.setEnabled(true);
        }
    }
    
+   @Override
+   public void render(float tpf) {
+       DisplaySystem.getDisplaySystem().getRenderer().draw(physicsRoot);
+       super.render(tpf);
+   }
+
    public void setActive(boolean active) {
        super.setActive(active);
-       if (!active) {
-           thread.setEnabled(false);
+       if (!active) 
+       {
+           physicsRunnable.setEnabled(false);
        }
    }
    
    public void shutdown() {
-       thread.shutdown();
+       physicsRunnable.shutdown();     
    }
    
    public void lock() {
-       thread.lock();
+       physicsRunnable.lock();
    }
    
-   public void unlock() {
-       thread.unlock();
+   public void unlock() 
+   {
+       physicsRunnable.unlock();
    }
-}
 
-class PhysicsThread implements Runnable {
-   private PhysicsSpace physics;
-   private long preferredTicksPerFrame;
-   private boolean enabled;
-   private boolean keepAlive;
-   private Timer timer;
-   private boolean limitUpdates;
-   private Lock updateLock;
-   
-   public PhysicsThread(int desiredUpdatesPerSecond) {
-       physics = PhysicsSpace.create();
-       physics.update(0.01f);
-       enabled = false;
-       keepAlive = true;
-       updateLock = new ReentrantLock(true); // Make our lock be fair (first come, first serve)
-       
-       timer = new LWJGLTimer();
-       if (desiredUpdatesPerSecond == -1) {
-           limitUpdates = false;
-       } else {
-           preferredTicksPerFrame = Math.round((float)timer.getResolution() / (float)desiredUpdatesPerSecond);
-           limitUpdates = true;
+
+   private class PhysicsThread implements Runnable {
+       private PhysicsSpace physics;
+       private long preferredTicksPerFrame;
+       private boolean enabled;
+       private boolean keepAlive;
+       private Timer timer;
+       private boolean limitUpdates;
+       private ReentrantLock updateLock;
+       private Node physicsRoot = new Node();
+
+       private Condition enabledCondition;
+       public PhysicsThread(int desiredUpdatesPerSecond) {
+           
+           physics = PhysicsSpace.create();
+           physics.update(0.01f);
+           enabled = false;
+           keepAlive = true;
+           updateLock = new ReentrantLock(true); // Make our lock be fair (first come, first serve)
+           enabledCondition = updateLock.newCondition();
+           timer = new NanoTimer();
+           if (desiredUpdatesPerSecond == -1) {
+               limitUpdates = false;
+           } else {
+               preferredTicksPerFrame = Math.round((float)timer.getResolution() / (float)desiredUpdatesPerSecond);
+               limitUpdates = true;
+           }
+       }
+       
+       public PhysicsSpace getPhysics() {
+           return physics;
        }
-   }
-   
-   public PhysicsSpace getPhysics() {
-       return physics;
-   }
-   
-   public void setEnabled(boolean enabled) {
-       this.enabled = enabled;
-   }
-   
-   public boolean isEnabled() {
-       return enabled;
-   }
-   
-   public void run() {
-       // We have to lock it up while we're starting
-       lock();
        
-       long frameStartTick = 0;
-       long frameDurationTicks = 0;
-       float tpf;
-       while (keepAlive) {
-           if (limitUpdates) {
-               frameStartTick = timer.getTime();
+       public synchronized void setEnabled(boolean enabled) 
+       {//only one thread can change enabled at a time
+           
+           if (this.enabled != enabled)
+           {
+               this.enabled = enabled;
+               //this is only reached if the state of enabled has changed
+               if (enabled)
+               {
+                   //reset timer so it doesn't overestimate the tpf if the thread has been disabled for a while
+                   timer.reset();              
+                   if ((updateLock.isHeldByCurrentThread() || updateLock.tryLock()))//try to get the lock but don't block
+                   {
+                       try{
+                           enabledCondition.signalAll();//signal the main thread to check the enabled condition and acquire the lock
+                       }finally
+                       {
+                           updateLock.unlock();
+                       }
+                   }
+               }
+               this.enabled = enabled;
            }
-           timer.update();
-           tpf = timer.getTimePerFrame();
-           update(tpf);
-           if ((limitUpdates) && (preferredTicksPerFrame >= 0)) {
-               frameDurationTicks = timer.getTime() - frameStartTick;
-               while (frameDurationTicks < preferredTicksPerFrame) {
-                   long sleepTime = ((preferredTicksPerFrame - frameDurationTicks) * 1000) / timer.getResolution();
-                   try {
-                       Thread.sleep(sleepTime);
-                   } catch (InterruptedException exc) {
-                       Logger.getLogger( PhysicsSpace.LOGGER_NAME ).log(Level.SEVERE, "Interrupted while sleeping in fixed-framerate",
-                                       exc);
+           
+       }
+       
+       public boolean isEnabled() {
+           return enabled;
+       }
+       
+       public void run() {
+           // We have to lock it up while we're starting
+           lock();
+           try{
+               long frameStartTick = 0;
+               long frameDurationTicks = 0;
+               float tpf;
+               while (keepAlive) {
+                   try{
+                       while (!enabled && keepAlive)                           
+                           enabledCondition.await();//put the thread to sleep if it is not enabled 
+                   }catch(InterruptedException e)
+                   {
+                       Logger.getLogger( PhysicsSpace.LOGGER_NAME ).log(Level.SEVERE, "Interrupted while disabled",e);
+                   }
+                   if (limitUpdates) {
+                       frameStartTick = timer.getTime();
                    }
-                   frameDurationTicks = timer.getTime() - frameStartTick;
+                   timer.update();
+                   tpf = timer.getTimePerFrame();
+                   update(tpf);
+                   if ((limitUpdates) && (preferredTicksPerFrame >= 0)) {
+                       frameDurationTicks = timer.getTime() - frameStartTick;
+                       while (frameDurationTicks < preferredTicksPerFrame) {
+                           long sleepTime = ((preferredTicksPerFrame - frameDurationTicks) * 1000) / timer.getResolution();
+                           try {
+                               Thread.sleep(sleepTime);
+                           } catch (InterruptedException exc) {
+                               Logger.getLogger( PhysicsSpace.LOGGER_NAME ).log(Level.SEVERE, "Interrupted while sleeping in fixed-framerate",
+                                               exc);
+                           }
+                           frameDurationTicks = timer.getTime() - frameStartTick;
+                       }
+                   }
+                   Thread.yield();
                }
+           }catch(Exception e)
+           {//if its necessary, create a new physics state altogether...
+               e.printStackTrace();
+           }catch(Error e)
+           {
+               e.printStackTrace();
+               throw (e);
+           }finally
+           {
+               System.out.println("Physics Died");
+               unlock();
            }
-           Thread.yield();
+           
        }
-   }
-   
-   public void update(float tpf) {
-       if (!enabled) return;
-       // Open the lock up for any work that needs to be done
-       unlock();
-       // Now lock up again so nothing can happen while we're updating
-       lock();
        
-       physics.update(tpf);
-   }
-   
-   public void lock() {
-       updateLock.lock();
-   }
-   
-   public void unlock() {
-       updateLock.unlock();
-   }
+       public void update(float tpf) {
+           if (!enabled) return;
+           // Open the lock up for any work that needs to be done
+           updateLock.unlock();//call this directly (not through unlock) so that it doesn't check the enabled condition
+           // Now lock up again so nothing can happen while we're updating
+           updateLock.lock();
+           //update the geometry of the physics node here
+           physicsRoot.updateGeometricState(tpf, true);
+           physics.update(tpf);
+           
+       }
+       
+       public void lock() {
+           updateLock.lock();
+       }
+       
+       public void unlock() {
+           if (enabled)//this handles the case where the thread could not be locked at the time enabled was called
+               enabledCondition.signalAll();       
+           updateLock.unlock();
+       }
+       
+       public void shutdown() {
+           keepAlive = false;
+           
+           if ((updateLock.isHeldByCurrentThread() || updateLock.tryLock()))//try to get the lock but don't block
+           {
+               enabledCondition.signalAll();//signal the main thread to check the enabled condition and acquire the lock
+               updateLock.unlock();
+           }else
+           {   //if the lock cannot be acquired, this will wake the thread up from Condition.await() and cause the physics thread to test whether it is alive or not
+               PhysicsMultithreadedGameState.this.thread.interrupt();
+           }
    
-   public void shutdown() {
-       keepAlive = false;
+       }
+       
+       public Node getPhysicsRoot()
+       {
+           return physicsRoot;
+       }
    }
 }
Index: src/com/jmex/physics/geometry/PhysicsSphere.java
===================================================================
RCS file: /cvs/jmephysics/src/com/jmex/physics/geometry/PhysicsSphere.java,v
retrieving revision 1.11
diff -u -r1.11 PhysicsSphere.java
--- src/com/jmex/physics/geometry/PhysicsSphere.java    22 Sep 2007 14:28:37 -0000  1.11
+++ src/com/jmex/physics/geometry/PhysicsSphere.java    11 Jul 2009 22:23:56 -0000
@@ -70,7 +70,7 @@
     @Override
     public float getVolume() {
         float r = getWorldScale().x;
-        return r*r*r * 4/3 * FastMath.PI;
+        return r*r*r * 4f/3f * FastMath.PI;
     }
 
    @Override
Index: physicsRelease/odejava.dll-optimized-static
===================================================================
RCS file: physicsRelease/odejava.dll-optimized-static
diff -N physicsRelease/odejava.dll-optimized-static
--- /dev/null   1 Jan 1970 00:00:00 -0000
+++ physicsRelease/odejava.dll-optimized-static 1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,951 @@
+MZ?